var optDart = {method: 'rejection', samples: 1000}
var optProb = {method: 'rejection', samples: 1000}


var dartData = [
  {"person":1, "numObs": 1, "obsDifficulty": 1/6, "obsOutcome" : 'success', "taskDifficulty" : 1/6, "humanProb" : 0.1},
  {"person":2, "numObs": 3, "obsDifficulty": 1/6, "obsOutcome" : 'success', "taskDifficulty" : 1/6, "humanProb" : 0.1},
]

//var levels = function(a, lvl){ return _.uniq(_.map(a, lvl)) }

//var numObs = levels(dartData, "numObs");
//var obsDifficulty = levels(dartData, "obsDifficulty");
//var obsOutcome = levels(dartData, "obsOutcome");
//var taskDifficulty = {
//  easy: levels(_.filter(dartData, {taskDifficulty: 5/6}), "taskDifficulty"),
//  medium: levels(_.filter(dartData, {taskDifficulty: 3/6}), "taskDifficulty"),
//  hard: levels(_.filter(dartData, {taskDifficulty: 1/6}), "taskDifficulty"),
//};

var smoothToBins = function(dist, sigma, bins){
  Infer({method: "enumerate"}, function(){
    var x = sample(dist);
    var smoothedProbs = map(function(b){return Number.EPSILON+Math.exp(Gaussian({mu: x, sigma: sigma}).score(b)) }, bins)
    return categorical(smoothedProbs, bins)
  })
}

var round = function(x){
  return Math.round(x*10)/10
}

var bins = map(round, _.range(0, 1, 0.1))

var focusPrior = 0.7; 
var focusSkills = 0.8; //if skills<difficulty then success

var priorAKernel = function(){
  return Discrete({ps:repeat(10, function() {return 1})})
}

var priorBKernel = function(){
  return Discrete({ps:repeat(10, function() {return 1})})
}

var getPrior = function(a, b) {
  return Beta({a: a, b: b})
}

var dartModel = function(priorA, priorB, trialInfo) {
  Infer(optDart, function(){  
    
  var skills = mem(function(x){
    return uniform(0,1)
  })
  
  var focus = function(){ //is the person focused?
    return flip(focusPrior)
  }
  
  var throwing = function(x) {
    return focus() ? focusSkills*skills(x) :  skills(x)
  }
  
  var taskDifficulty = sample(getPrior(priorA, priorB))
  var outcome = function(taskDifficulty, x) {
    return throwing(x) <= taskDifficulty
  }
 
  var outcome2Str = function(outcome) {
    return outcome ? 'success' : 'fail'
 }
    
  trialInfo.numObs==1 ? 
    condition(outcome2Str(outcome(trialInfo.obsDifficulty, trialInfo.person))==trialInfo.obsOutcome) : 
    condition(outcome2Str(outcome(trialInfo.obsDifficulty, trialInfo.person))==trialInfo.obsOutcome &&
      outcome2Str(outcome(trialInfo.obsDifficulty, trialInfo.person))==trialInfo.obsOutcome &&
      outcome2Str(outcome(trialInfo.obsDifficulty, trialInfo.person))==trialInfo.obsOutcome)
    
  return outcome(trialInfo.taskDifficulty, trialInfo.person) 
})  
}

//to test model is working

var priorAtest = sample(priorAKernel()) + 1
var priorBtest = sample(priorBKernel()) + 1
print(priorAtest)
print(priorBtest)
viz(dartModel(priorAtest, priorBtest, dartData[0]))


var trialCondition2PrioVals = mem(function(testDifficult) {
  var priorA = sample(priorAKernel()) + 1
  var priorB = sample(priorBKernel()) + 1
  return [priorA, priorB]
})

var dataAnalysisModel = function(opts){
  Infer(opts, function() {
    mapData({data: dartData}, function(datum) {
      var abPrior = trialCondition2PrioVals(datum.taskDifficulty)
      var a = abPrior[0]
      var b = abPrior[1]
//       var focusEffect = prior()
      
      //var obshumanProb = sample(Bernoulli({p: datum.humanProb}))
      condition(sample(dartModel(a, b, datum))==flip(datum.humanProb)) 
    })

  return {
    "hard_params": trialCondition2PrioVals(1/6),
    "med_params": trialCondition2PrioVals(3/6),
    "easy_params": trialCondition2PrioVals(5/6)
    //"parameters": {priorA: priorA, priorB: priorB}
  }
  })
}
                        
var nSamples = 20
var opts = { method: "MCMC",
            callbacks: [editor.MCMCProgress()],
             samples: nSamples, burn: 0}

// var posterior = Infer(opts, dataAnalysisModel)
var posterior = dataAnalysisModel(opts)
// viz(posterior)
viz(marginalize(posterior, function(x) {
  x.hard_params
}))
viz(marginalize(posterior, function(x) {
  x.med_params
}))
viz(marginalize(posterior, function(x) {
  x.easy_params
}))
// editor.put("bda_bcm", posterior)
