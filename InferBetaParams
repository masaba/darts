var options = {method: 'rejection', samples: 10000}

var observedData = [
  {person:'bob', obsDifficulty: 1/6, obsOutcome : 'success', taskDifficulty : 1/6, humanProb : 0.1},
]

// fit the parameters
var focusPrior = 0.7; 
var focusSkills = 0.8; //if skills<difficulty then success

var model = function() {
  
  var task2probs = mem(function() {
    
  })
  // edited the line below with "3/6" (there were two "1/6" before)
  var prior = mem(function(task){
    var a = sample(Discrete({ps:repeat(10, function() {return 1})}))
    var b = sample(Discrete({ps:repeat(10, function() {return 1})}))
    return [a, b]
//     return (task==1/6) ? Beta({a:2,b:5}) : (task==3/6 ? Beta({a:5,b:3.75}):Beta({a:10,b:5}))
  })
  
  var getPrior = function(a, b) {
    return beta({a: a, b: b})
  }
       
  var skills = mem(function(person){
    return uniform(0,1)
    // tug of war model used a gaussian here -- return Math.abs(gaussian(1, 1), 0.01)
  })
  
  var focus = function(person){ //is the person focused?
    return flip(focusPrior)
  }
  
  var throwing = function(person) {
    return focus(person) ? focusSkills*skills(person) :  skills(person)
  }

  var outcome = function(person, task){
    var params = prior(task)
    var priorDistr = getPrior([params[0], params[1]])
    var taskDifficulty = sample(priorDistr)
    return throwing(person) <= taskDifficulty ? 'success' : 'fail'
  }
  
  // added this, similar to outcome but returns whether success is true or false
  var success = function(person, task){
    var taskDifficulty = sample(prior(task))
    return throwing(person) <= taskDifficulty
  }
  
  var probSuccess = function(person, task){
    // prob of success inferred by the model
    // return integral of (prior(task)) between 0 and throwing(person)
  }
  
  var obsFn = function(datum){
    condition(outcome(datum.person, datum.obsDifficulty)==datum.obsOutcome) //=datum.success
  }
  
  mapData({data: observedData}, obsFn)

  //return skills('bob')
//   return success('bob', 5/6)
  return {'hard_params_a': prior(1/6)[0],
          'hard_params_b': prior(1/6)[1],
          'medium_params_a': prior(3/6)[0],
          'medium_params_b': prior(3/6)[1],
          'easy_params_a': prior(5/6)[0],
          'easy_params_b': prior(5/6)[1]}
  
}

var posterior = Infer(options, model)
// print("Bob's skills, given that he succeeds on a 50% task")

// print("Expected value = " + expectation(posterior))
// viz(posterior, {bounds: [0,1]}) //viz.density

viz.marginals(posterior)
